/**
 * This code demostrates how to use TIM2 to generate an interrupt every second.
 * 
 * Interrupt is handled in the TIM2_IRQHandler function and toggle LED state.
 */
#define STM32F103x6
#include "stm32f1xx.h"


#define PRESCALER     (1000 - 1)
#define TIMER2_VALUE  (72000 - 1)


static void init_clock(void) 
{
    // Enable external high-speed oscillator (HSE)
    RCC->CR |= RCC_CR_HSEON;
    while (!(RCC->CR & RCC_CR_HSERDY)) {}

    // Configure flash: 2 wait states for 72MHz
    FLASH->ACR |= FLASH_ACR_LATENCY_2;

    // PLL: HSE * 9 = 72 MHz
    RCC->CFGR |= RCC_CFGR_PLLMULL9 | RCC_CFGR_PLLSRC;
    RCC->CR |= RCC_CR_PLLON;

    while (!(RCC->CR & RCC_CR_PLLRDY)) {}

    // Switch system clock to PLL
    RCC->CFGR |= RCC_CFGR_SW_PLL;
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL) {}
}

/**
 * @brief Initialize GPIO for LED control.
 *
 * This function enables the clock for GPIO Port C and configures PC13 pin
 * as a push-pull output with a maximum speed of 2 MHz. The pin is typically
 * used to drive an on-board LED. The configuration clears the mode and configuration
 * bits first, then sets the appropriate mode bits for general purpose output.
 */
static void init_led_gpio(void) {
  RCC->APB2ENR |= RCC_APB2ENR_IOPCEN; // Enable clock for PORT C
  
  GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13); // set push-pull mode
  GPIOC->CRH |= GPIO_CRH_MODE13_1; // set output mode with 2 MHz speed
}

/**
 * @brief Initializes a 1-second timer using TIM2.
 *
 * This function configures TIM2 to generate an update interrupt every 1 second
 * based on the APB1 clock (assuming 72 MHz). The timer is set up with a prescaler
 * and auto-reload value to achieve a 1 Hz frequency (1 second period).
 *
 * Steps performed:
 * 1. Enables the TIM2 clock via APB1 peripheral clock enable register.
 * 2. Sets the prescaler (PSC) and auto-reload register (ARR) to divide the clock
 *    such that the timer overflows once per second.
 * 3. Enables the update interrupt (UIE) in the DIER register to trigger an interrupt
 *    on overflow.
 * 4. Starts the timer by enabling the counter (CEN bit in CR1).
 * 5. Enables the TIM2 global interrupt in the NVIC to allow interrupt handling.
 *
 * @note This function assumes the core clock is 72 MHz.
 * @note The constants PRESCALER and TIMER2_VALUE must be defined externally
 *       to achieve the correct timing (e.g., PRESCALER = 1000, TIMER2_VALUE = 72000).
 * @note The corresponding interrupt service routine (ISR) must be implemented
 *       separately (e.g., TIM2_IRQHandler).
 */
static void init_1s_timer(void) {
    // 1. Enable TIM2 clock
    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    // 2. Configure timer
    TIM2->PSC = PRESCALER; // Prescaler to 1000. Input clock is 72 MHz. Timer clock = 72 MHz / 1000 = 72 kHz
    TIM2->ARR = TIMER2_VALUE; // Auto-reload value = (TIM2_CLK / (PSC+1)) / 1Hz - 1


    // 3. Enable update interrupt
    TIM2->DIER |= TIM_DIER_UIE; // Enable Update Interrupt

    // 4. Enable timer
    TIM2->CR1 |= TIM_CR1_CEN; // Enable Timer Counter

    // 5. Enable timer interrupt in NVIC
    NVIC_EnableIRQ(TIM2_IRQn);
}

/**
 * @brief TIM2 global interrupt handler.
 *
 * This function handles the interrupt generated by TIM2 when an update event occurs.
 * It checks if the update interrupt flag is set, clears it, and toggles the state
 * of the LED connected to pin PC13.
 *
 * @note The LED is assumed to be connected to GPIO pin 13 of port C and is
 *       controlled by toggling the corresponding bit in the ODR register.
 */
void TIM2_IRQHandler(void) {
    // Check if the update interrupt flag is set
    if (TIM2->SR & TIM_SR_UIF) {
        // Clear the flag
        TIM2->SR &= ~TIM_SR_UIF;

        // Toggle the LED on PC13
        GPIOC->ODR ^= GPIO_ODR_ODR13;
    }
}

int main(void) {
    // Initialize clock system to 72 MHz
    init_clock();
    
    // Configure PC13 as output
    init_led_gpio();

    // Initialize timer for 1 second interrupt
    init_1s_timer();

    while (1) {
        // Main loop can do other things
    }
}
